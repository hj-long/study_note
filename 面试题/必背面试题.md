## 1、cookie 和 session 的区别

cookie 和 session 都是用于客户端和服务器端之间进行状态管理的技术，它们的区别主要有：

1. 存储位置不同：

    cookie 存储在客户端浏览器中，而session存储在服务器端的内存或者数据库中

2. 安全性不同：

    cookie 可以被客户端浏览器禁用或者删除，也容易被恶意攻击者窃取和篡改，因此存储敏感信息的安全性较低，而session存储在

服务器端，客户端无法直接访问，相对来说比较安全

3. 存储容量不同：

    cookie 的存储容量比较小，一般不超过4kb；而session的存储容量比较大，可以存储更多的信息

4. 过期时间不同：

    cookie的可以设置过期时间，可以长期保存在客户端浏览器中；而session的过期时间一般比较短，用户在关闭浏览器或者一段时间不活动之后就会自动过期

5. 用途不一样：

    cookie主要用于客户端浏览器与服务器端之间的状态管理，比如保存用户登录信息、购物车信息等；而session一般用于服务器端的状态管理，比如保存用户的会话信息、

缓存数据等。

总之，cookie和session都有各自的优缺点，具体使用哪种技术要看具体的需求和场景来决定。


## 2、slot 的使用

vue中的插槽有三种类型：匿名插槽、具名插槽、作用域插槽

1. 匿名插槽：

    子组件通过 slot 标签来确定插槽渲染的位置，标签内可以放入Dom结构，当父组件在使用的时候没有往插槽传入内容，标签内的dom结构就会显示在页面上；

父组件在使用的时候，直接在子组件的标签内写入内容就可以了

2. 具名插槽：

    子组件通过 name 属性来表示插槽的名字，不传就为默认插槽；

父组件在使用的时候在默认插槽的基础上加上 slot 属性，值就是子组件的插槽的 name 属性值

3. 作用域插槽：

    子组件在作用域插槽上绑定属性将自身的信息传递给父组件来使用，这些属性会挂载到父组件的 v-slot 接收的对象上；

而 v-slot 可以简写为 #，父组件通过 # 加上插槽名字 来获取子组件的信息，在内容中使用。

总结一下，有一些需要注意的地方：

- v-slot 只能在 template 标签上使用，但是当只有默认插槽的时候，可以在组件标签上使用

- 默认插槽的名字为 default ，可以省略 default 直接写 v-slot

- 当 v-slot 简写为 # 时，不能省略参数，写成 #default

- 可以通过解构获取子组件传递的变量：v-slot={user}，也可以重命名变量：v-slot="{user: aaa}"，还可以设置默认值：v-slot="{user='默认1'}"


## 3、computed 是怎么做响应式的？

computed属性是vue中的计算属性，它是一个类似于过滤器的函数，主要用于对绑定到视图的数据进行处理

- 计算属性的输出结果会被缓存下来，只有当它依赖的响应式属性发生变化才会重新计算；

- computed 属性也是响应式的，它会自动追踪依赖的响应式属性，也就是说，当依赖的响应式属性发生变化时，computed属性会重新计算，然后更新视图

- 与 methods 不同，computed 属性会自动追踪响应式依赖，不需要手动追踪，计算属性的结果是默认走缓存的，也就是基于在data中声明过的或者父组件
传递的props中的数据进行计算得到的值


## 4、vue2 和 vue3 的区别

1. 数据双向绑定 的原理不同：

在vue2中，数据双向绑定是利用 ES5 的一个 API 叫 Object.defineProperty 对数据劫持，并且结合发布订阅模式的方式去实现的

而在vue3中，数据双向绑定是使用 es6 的 Proxy 方法对数据进行代理，相比于 vue2 ，proxy 有几个好处：

- Object.defineProperty 只能监听对象的某个属性，不能对整个对象进行监听，因此 vue2 需要递归遍历所有的属性去对数据进行劫持，而 proxy 可以直接对
整个对象代理进行监听，因此节省了递归遍历等操作，明显提高了性能
    
- 可以监听数组，不用像vue2中那样对数组做特异性操作，vue3可以检测到数组内部数据的变化

2. vue3 支持 碎片化

在vue2中，template 模板标签下必须并且只能有一个根节点

而在vue3中，可以支持多个根节点

3. API 类型不同：

在 vue2 中使用的是选项式API的写法，根据不同的属性来分割代码：data、computed、methods等，当代码量比较大的时候，需要不断地上下翻滚查找数据和方法
开发可能会比较麻烦

而 vue3 采用的是 组合式API的写法，同一个业务的数据和方法写在同一个地方，相比于 vue2 的写法，vue3 的代码会更加方便和整洁

4. 定义数据变量和方法不同：

vue2 的数据变量放到 data 中管理，创建的方法放到 methods 中管理

而 vue3 的数据和方法是写到 setup 函数里面，setup 函数会在组件初始化构造的时候触发

5. 生命周期钩子函数不一样：

vue2 中的生命周期有：

    组件创建前和后：beforeCreate、created

    组件挂载前和后：beforeMount、mounted

    数据更新前和后：beforeUpdate、Updated

    以及组件销毁前后：beforeDestroy、destroyed

vue3 的生命周期把组件创建前后改成了 setup

    组件挂载前和后：onBeforeMount、onMounted

    数据更新前和后：onBeforeUpdate、onUpdated

    组件销毁前后改了名称，叫：onBeforeUnMount、onMounted

    并且 vue3 中的生命周期在使用之前要先引入。

6. 父子组件传参的方式不同

vue2 中的 父传子，子组件使用 props 接收，而 子传父使用 this.$emit 传入事件名称来触发父组件的方法并且通过参数传值

而在 vue3 的 setup 语法糖里面，父传子使用的是 defineProps 来接收，子传父使用的是 defineEmits

7. 插槽和指令不同

- 插槽：

    vue2 中的插槽可以直接使用 slot 指令，而 vue3 中必须使用 v-slot 指令

- 指令：

    vue2 中的 v-for 比 v-if 的优先级要高，并且不建议一起使用，而在 vue3 中，v-if 只是作为 v-for 的一个判断语句
不会相互冲突；

    并且在 vue3 中，移除了 keyCode 作为 v-on 的修饰符，以及移除了 v-on.native 修饰符，还有一个过滤器 filter 也从 vue3 中移除了

8. main.js 文件不同

在 vue2 的main.js中，引入的是 Vue 的构造函数，并且可以使用 prototype 操作原型的方式去添加全局对象或者方法

在 vue3 中则是引入了一个名叫 createApp 的工厂函数，通过模块化的方式去组织代码，比vue更加简洁

并且 vue3 的 app.vue 组件可以没有根标签


## 5、解释一下 MVVM

MVVM 就是 model-view-viewModel，本质上是 MVC 的改进版

model 代表数据模型，数据和业务逻辑都在model层定义

view 是用户在屏幕上看到的UI视图

viewModel 负责监听 model 中数据的改变并且控制视图的更新，以及处理用户的交互逻辑

MVVM 优点是：

- 低耦合，view视图可以独立于model的变化和修改，一个viewModel可以绑定到不同的view上，view和model无直接的关联，互不影响

- 可复用性强，就是开发者可以把一些视图逻辑放在一个viewModel里面，让很多view可以复用这段逻辑

- 独立开发，业务逻辑和视图表现是分离，开发者可以专注于业务逻辑，不用过多关注界面的细节


## 6、vue 的特点

vue 是一个轻量级的 JavaScript 框架，专注于视图层开发，用于构建单页面应用

还有，vue 使用 MVVM 架构，将视图层、数据层和业务逻辑分离开来，通过一些简单的API实现响应式的数据绑定和可以组合的视图组件，
让开发者可以更方便地开发和维护复杂的前端应用

vue 的特点：

一个是 数据双向绑定 机制，就是说当数据发生变化时，视图也会进行更新，不需要手动去操作 DOM 

还有一个是 组件化 开发，把代码分割成一个个独立的组件，方便我们开发和复用，同时也可以提高代码的可维护性和可扩展性

此外，vue 还有丰富的插件生态，比如路由管理的 vueRouter、状态管理的 vuex 等，提高开发效率

总的来说，vue 的优点在于它的灵活性和轻量级，它的语法、指令简单明了，学习成本低，不管是小型应用还是大型单页面应用，都可以使用 vue 来实现


## 7、什么是单页面应用（SPA）

单页面应用，也叫 single-page application 简称 SPA，也就是加载单个页面并在交互时动态刷新该页面，所有的
活动都在一个页面中进行。

单页面应用在初始化时加载相应的HTML、CSS、JavaScript 文件，利用 js 动态的切换 HTML，从而实现UI与用户的交互效果

vue 框架为单页面应用开发提供了模板、路由和异步访问数据api以及DOM操作等功能，使得前后端分离开发成为了可能

SPA的优点是：

1. 前后端分离开发，减轻了服务器的压力；

2. 移动端和PC端等可以共用一套后端接口程序代码，节省了开发成本。

SPA的缺点是：

1. SEO 难度比较高，首次加载时耗时比较长

2. 页面前进、后退的管理比较困难

针对单页面应用的前进后退的管理问题，我们可以引入 vueRouter 实现单页面应用的路由配置和导航控制，通过浏览过的一个历史记录，查看过往的页面

还有首次加载耗时长的问题，可以采用多种缓存措施，在需要的时候再进行加载模块，比如路由懒加载、数据懒加载等

最后是 SEO 优化问题，由于单页面应用的数据是动态刷新的，导致网页内容很难被搜索引擎抓取到。

一般有两种解决方案：一种是服务端渲染，还有一种是前端预渲染。

关于前端预渲染：

1. 使用插件 prorender-spa-plugin，下载安装之后在 vue.config.js 中进行配置，配置好这个默认预编译的路劲、路由和渲染方式

2. 然后在 main.js 中引入，并且要把 vueRouter 路由模式改成 history,然后进行打包


##  8、data为啥是函数

在js中，对象是引用数据类型，也就是说如果 data 是一个对象时，每个组件实例的data对象引用的都是同一个内存地址，一个实例数据改变了，其他的
data也会收到影响跟着改变；

而如果 data 是一个函数，它会创建一个函数作用域作为自己的私有域，每个组件实例的data都是独立的，互不影响，可以保证组件的一个正常工作。

## 9、数据双向绑定的原理

vue 中实现的这个数据双向绑定，首先要对数据进行劫持监听，用到了 Object.definedProperty() 的 get 和 set 方法，然后还需要一个监听器 Observer，
来监听所有属性。如果属性发生了变化，就告诉订阅者 Watcher 看是否需要更新。

因为 订阅者 是有很多个的，所以需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和 订阅者 Watcher 之间进行一个统一管理。

接着，我们还需要有一个指令解析器 Compile，对每个元素节点进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并且替换模板数据或者绑定相应的函数，
此时当订阅者 Watcher 接收到相应属性的变化时，就会触发执行对应的更新函数，这一点实在 js 文档碎片中完成的，从而更新了视图。

以上就是我所了解的数据双向绑定的原理~


## 10、computed、methods、watch

computed 是 vue 中的计算属性，它可以用来解决模板过重的问题。计算属性必须要 return 返回一个结果，并且具有缓存功能，可以提高性能。

computed 注重这个计算结果，不支持异步操作。

methods 选项是用来存放方法的，方法可以用来处理事件绑定和逻辑计算，跟 computed 不同，方法可以不用 return 一个结果，并且没有缓存功能。

watch 可以用来监听某一个值的变化，在值发生变化的时候可以做一些操作。watch 也可以不用 return 返回值，也没有缓存。但是它同时支持异步或者同步操作。

总之，computed、methods以及 watch 都是用于处理数据的选项，它们各自具有不同的特点和使用场景。可以根据具体的业务需求和场景来使用。


## 11、v-if 和 v-show 的区别

v-if 和 v-show 这两个指令都可以用来控制 DOM 元素的显示和隐藏，不同的是：

v-if 是真正的条件渲染，它会在元素显示隐藏的切换过程中销毁和重建条件块内的事件监听器和子组件；而v-show只是简单的基于CSS样式来进行切换。

v-if 在首次渲染时，如果条件为真，就会创建和渲染条件块的元素，如果条件为false，那它什么也不会做；

而 v-show 在首次渲染时，不管条件为真还是假，都会创建和渲染元素

总结一下，v-if 是切换的开销高，v-show 的初次渲染的开销才比较高，

因此，如果是需要频繁进行切换的场景，使用 v-show 性能会更好，如果条件很少改变，使用v-if可能会比较好。

但还是需要结合具体的业务需求和场景来选择使用。


## 12、为什么 v-for 中必须要有 key

key 是 虚拟DOM 中用于识别节点的唯一标识符，它可以帮助 vue 高效地更新虚拟DOM，避免元素错乱等问题。例如，在使用 v-for 渲染列表时，如果
没有给每个元素加上一个唯一的key，就会导致元素发生错乱。

vue 的DOM操作默认采用“就地复用”策略，也就是说，当数据项的顺序发生变化时，vue会复用已有的元素来提高性能，而不是重新创建DOM元素。

最后需要注意的是，key 属性的类型只能是 number 或者 string 类型。

以上就是我了解的为什么要有 key 的原因

***追问***：key 的作用原理




## 13、vue 中的指令

指令就是针对 DOM 和数据操作而定义的一组具有特殊功能的命令

指令分为 系统指令 和 自定义指令

1. 系统指令主要有：v-if、v-show、v-for、v-model、v-text、v-html 等

2. 自定义指令也可以分为：全局自定义指令 和 局部自定义指令

- 全局自定义指令：

    在全局文件main.js中通过 directive 属性挂载 Vue 构造函数上

- 局部自定义指令：

    在组件的钩子函数 directives 中进行声明

3. 应用场景：

    用于数据类的，格式化一些内容、校验等，例如：微博的评论，有个显示评论时间的，我们可以通过自定义指令，
把时间小于2分钟的改成 刚刚、时间超过两分钟就显示 2分钟前、3分钟前...

    还有可以用于控制元素的状态比如是否可用的等


***追问***：vue 中自定义指令怎么实现的？

1. 全局自定义指令：

```
// vue2 写法，在 Vue 构造函数中挂载
Vue.directive()

// vue3 写法，在实例对象 app 上挂载
app.directive('指令名称', (el, binding) => {
    // el 是绑定的元素, binding 是绑定指令的对象，binding.value 可以获取绑定属性值
    //可选生命周期：created、beforeMount、Mounted、beforeUpdate、updated、beforeUnMount、UnMounted
})
```

2. 局部自定义指令：在组件中注册使用，在组件的钩子函数 directives 中进行声明

```
// 选项式写法：
directives: {
    'xxx': {
        mounted(el, binding) {xxx}
        .....
    }
}

// setup 语法糖
const vColor = {
    mounted(el, binding) {xxx}
    .....
}
```


## 14、vue的生命周期、 mounted 和 created 的区别

vue2 完整的生命周期，主要包括以下四个阶段：创建、挂载、数据更新、组件销毁

- 组件创建前的生命周期是：beforeCreate   创建后：created

- 挂载到DOM前的生命周期是：beforeMount   挂载后：mounted

- 组件数据更新前：beforeUpdate          更新后：updated

- 组件销毁之前： beforeDestroy          销毁后：destroyed

还有当组件初次加载时，会执行前面4个生命周期，就是：beforeCreate、created、beforeMount、mounted

如果使用了 keep-alive 就会新增两个生命周期，分别是：activated 和 deactivated。

关于生命周期钩子函数，它们在组件的不同阶段运行，完成一些特定的操作：

1. beforeCreate：这个生命周期是组件创建之前调用，此时数据观测和事件初始化还没开始，data的响应式追踪、event\watcher 都还没被设置，
也就是说这时候不能访问到data、methods、computed、watcher 上面的方法和数据

2. created： 这时候组件实例创建好了，并且实例上面配置了：data、methods、computed、watcher等选项里面的数据和方法，
但是此时渲染节点还没开始挂载到DOM上，因此访问不到 `$el` 属性

3. beforeMount：是在组件实例挂载之前调用，此时实例完成了模板编译，并将 data 里面的数据生成虚拟DOM

4. mounted：这时是在 el 被新创建的 vm.$el 替换，并且挂载到实例上之后调用。

5. beforeUpdate：数据更新时调用，发生在虚拟DOM重新渲染之前

6. updated：由于数据更改导致虚拟 DOM 重新渲染，然后就会调用这个生命周期，此时 页面上的 DOM 已经更新了

7. beforeDestroy：实例销毁之前调用。在这一步，组件实例还是完全可用的

8. destroy：组件实例销毁之后调用。调用后，vue实例会解除所有的数据绑定，包括所有的事件监听器，子组件实例等都会被销毁解除

还有一个特殊的 errorCaptured：会在捕获到一个来自子孙组件的错误时被调用


### vue3 的生命周期跟 vue2 的大同小异，但是用法和名字不太一样了

vue3 中 组件创建前后beforeCreate和created 改为使用 setup 函数， 组件的数据和方法在 setup 函数中定义。

然后 组件挂载到页面渲染前后的生命周期、还有数据更新前后的生命周期，在 vue2 的基础上，多加了 on 在名字前面，

例如：onBeforeMount、onMounted、onBeforeUpdate、onUpdated

最后组件销毁前后的生命周期的名字改为了 unMounted：

销毁前：onBeforeUnMount、销毁后：onUnMounted

### create 和 mounted 的区别：

created 是在组件渲染之前调用的，能拿到数据但是拿不到模板的

mounted 是在组件数据挂载并且渲染页面之后调用的，因此模板和数据都可以拿到



## 15、组件通信

1. 父传子：

    父组件通过 props 向子组件传递数据，就是在父组件中变量通过在子组件标签上用 v-bind:属性名='data'，
绑定属性名，值为父组件中的data数据，而子组件使用 props:['data']，用数组或者对象的形式声明属性值来接收父组件传递过来的数据

2. 子传父：

    子组件通过 this.$emit() 向父组件发送事件，在父组件中定义这个事件和方法，数据会以参数形式传递到父组件中

3. 兄弟组件通信：

    通过新建一个 bus.js 文件，里面 new 一个 vue 组件实例并且导出这个实例，然后假设有 A 、B 两个兄弟组件

在 A 组件中导入这个 bus.js，使用 bus.$emit() 传递事件和数据，然后 B 组件中也引入 bus.js ，使用 bus.$on() 来接收事件和定义
回调函数来处理传递过来的参数

还可以使用 vuex 的方式来通信：[vuex的理解](#16vuex-的理解)



## 16、vuex 的理解

vuex 是 vue.js应用程序 的状态管理库，就像一个 store 仓库，保存着程序中的大部分状态，它的核心概念有：

state： 是数据源，用来保存所有组件的公共数据

getter：getters 的返回值会被缓存下来，只有当它的依赖值发生变化才会重新计算，类似于计算属性

mutations：定义方法用来更新 state 中的数据，必须是同步的，在组件中通过 store.commit 来调用

actions：actions 可以使用异步方法，在组件中通过 store.dispatch 来调用并提交到 mutations 来更改数据

最后一个是 module：当应用程序比价大的时候，通过 module 可以包含其他的 vuex 模块

但是 vuex 存储的数据在刷新页面就会丢失，因此需要做持久化存储：

1. 可以使用 localStorage 做持久化存储，

2. 也可以使用第三方插件：比如 vuex-persistedstate ，安装之后在 store/index.js 中
引入插件，然后在 new vuex.store 中配置一下这个 plugins: [createPersistedState()]，这样 vuex 的数据就会持久化到 localStorage 中

这个插件本质上也是利用 localStorage 进行持久化存储的

***追问***：在什么场景下应用 vuex

如果项目中有需要在多个组件之间管理和共享状态的数据，就可以使用 vuex 来解决，例如 我之前做的一个项目里有一些商品需要收藏
或者类似小说网站那种书签、小说收藏、书架数据、搜索框历史记录等功能，就可以使用 vuex 来管理。

例如收藏夹功能就可以在 vuex 中 state 记录商品数据信息列表，当本地有就直接用本地的数据，如果没有，就从接口请求回来。


（如果数据比较重要，就发送到后端进行保存，如果数据不重要，就本地存储就好了）



## 17、get 和 post 的区别

get 和 post 是 http 协议中两种不同的请求方法

get 请求一般用来查询数据，通过 url 传递参数，就是拼接到 url 后面，而且参数有长度限制，只能用 url 来编码，
还有一点是 get 请求可以被缓存下来，也可以添加到浏览器书签上。

post 请求一般用来提交数据的，例如提交表单数据或者文件文件上传等，post 请求的参数放到请求体中，参数的长度没有限制
也可以使用多种编码方式，跟get请求不同，post不能被缓存。



## 18、常见的跨域方式

跨域是由于浏览器的同源策略导致的，在浏览器中，如果当前页面请求一个不同源的url时，就会触发这个跨域的问题，常见的解决方法有：

1. **jsonp**：利用script标签不受同源策略影响的特性，动态创建 script 标签，src 属性值就为请求的url，来获取其他域下的数据；
同时将回调函数作为参数传递给服务器，服务器在响应时将数据作为回调函数的参数来返回，响应完成时，客户端通过执行回调函数来获取数据。

2. **CORS**：跨域资源共享，它允许服务器端通过设置响应头比如 `Access-Control-Allow-Origin` 来告诉浏览器允许这个跨域请求，前端在发送请求时
在请求头加上 Origin 字段就可以了。这个也是官方推荐的一种跨域解决方案。

3. **使用代理服务器跨域**：通过代理服务器将跨域请求转发到目标服务器，有好几种实现方法，可以使用 Nginx 进行反向代理，
也可以在 vue 项目中的一个配置文件中设置 proxy 属性来开启代理服务

4. **postMessage**：html5 的 window.postMessage 方法，第一个参数为发送的消息，第二个参数为指定域地址，然后通过 window.addEventListener('message',()=>{}) 添加message事件监听来接收信息

5. **使用 WebSockets**： WebSockets 可以实现跨域通信，因为它们不受同源策略限制。通过建立一个 WebSocket 连接，客户端和服务器可以进行双向通信，实现跨域数据交换。



## 19、axios 二次封装

axios 是一个基于 promise 的网络异步请求库，我们可以通过二次封装方便使用：

新建 utils/request.js ，导入 axios，可以设置 baseURL、timeOut 超时时间等配置项，然后还可以定义：

1. 请求拦截器 interceptors.request.use，可以在这里设置每个请求携带是否 token 等操作

2. 响应拦截器 interceptors.response.use，收到响应之后的处理，可以在这里处理不同状态码的操作

然后还可以再封装一层 api 的解耦，根据不同的模块定义发送请求的函数，然后可以根据需要去调用


## 20、async 和 await 

async 用来定义异步函数，该函数不会阻塞后面的代码。async 语句会把这个函数包装成promise对象，可以使用 .then 获取返回值

async 函数内部原理是：

如果这个 async 函数有返回值，就会使用 resolve() 把它转化成promise对象来返回

如果这个 async 函数内部报错了，调用 reject() 返回 promise 对象，可以用 catch 来捕获错误

然后 await 语句，是等待的意思，它必须要在 async 函数内部配合使用，await后面一般跟着promise对象，
它会把async函数挂起，直到promise对象返回结果才继续往下执行

async 和 await 的优势是：

它可以像写同步代码一样来写异步代码，比 promise 写法更直观一点，提高效率（promise 解决了回调地狱问题）


## 21、接口安全

前后端在进行数据传输的时候，为了防止请求被抓包、伪造、偷窥等情况，一般需要对数据进行加密，我们前端常用的有 md5，crypto、jsencrypt 等… 

说一下我们之前常用的加密解密方式：

第一种是 crypto，属于 AES 算法，首先通过 npm 下载，然后在 utils/cryptoAES.js 文件，导入 crypto，定义一个加密函数和一个解密函数

其中就会用到密钥和偏移量，这个密钥跟偏移量是前后端约定好的。使用的时候在组件组件中导入这个文件就可以了，然后使用加密函数进行加密

第二种是 jsencrypt，它属于 RSA 加密，RSA算法是一种非对称加密算法，这个插件可以采用双向加密解密，前端有一对公钥和私钥，后端也有，
也就是说， 就算拿到前端的公钥和私钥也没办法解密，加密安全系统很高。

用法也一样，npm 下载，导入并且定义加密解密函数来使用就可以了


## 22、 对单向数据流的理解

在 vue 中，父组件通过 props 向子组件传递的数据，子组件不能直接修改，而如果父组件的数据更新了，子组件的也会跟着变化，这就是一个单向数据流，

可以确保数据只能从父组件流向子组件，可以很好追踪数据源，降低程序出错可能性。

如果子组件想要修改父组件的传递的数据：

1. 可以在子组件 data 中新建一个变量赋值 props 中的值，然后再去修改这个变量就可以了

2. 可以通过 this.$emit 发出一个事件，父组件收到事件去做相应的一个修改逻辑



## 23、对路由的理解

在 vue 中，路由是可以根据不同的 url 来切换显示不同内容的控制器、通常使用 vue-router 来实现路由功能

路由有两种模式：hash 和 history，默认使用hash模式，在 router/index.js 中配置

hash 路由模式会在 url 后面带有一个 # 号，当 url 的hash发生变化时，浏览器不会重新加载整个页面，而是会触发
hashchange事件，就可以通过js来监听这个事件实现数据的加载和页面渲染；

而 history 模式会刷新页面，会向后台服务器发送请求，如果后台没有定义这个路径的话，会返回404，因此需要后台配置重定向

路由的使用方法：首先需要通过 npm 下载 vue-router，需要在 src/router/index.js 中引入 vue-router，需要配置包括 path、
name、component、children 等属性

然后还可以分为静态路由和动态路由：

1. 静态路由：就是路由的path固定不变的

2. 动态路由：路由的path/：参数名称，比如说：`` path:"/users/:id" ``，：号跟着一个参数id，在组件中使用的时候，通过
this.$router.push(url, 参数) 进行带参数跳转，可以使用 query 和 params 来传参

然后还有 $route 和 $router 的一个区别：

1. $route：表示当前的路由信息，包含了当前页面的url路径、参数、query对象等内容

2. $router 对象是全局的路由实例，包含一系列路由方法：

    - 比如 router-link 标签，可以声明一个路由链接

    - this.$router.push() 可以向 history 栈中添加一个新的记录

    - this.$router. replace() 替换，这个不会向 history 栈中添加新记录

    - this.$router.go(n) 方法，可以传递数字参数n，可以是正整数也可以负整数，表示向前或者向后跳转 n 个页面

还有路由的懒加载，可以按需加载路由文件，减少首页加载时间，避免首页出现白屏

最后是路由守卫：

1. 全局路由守卫：放在 main.js 的 router 实例上，beforeEach((to:即将进入, from:当前离开, next:下一步) => {})，afterEach((to, from)=>{})

2. 局部路由守卫：在每个组件中定义的，beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

3. 路由独享守卫：只在当前的路由中生效，有两个 beforeEach、afterEach，在 /router/index.js 中配置的一个个路由信息下定义


***追问***：hash模式 和 history模式 的原理和区别

hash 路由模式：会在 url 后面带有一个 # 号，当 url 的hash发生变化时，浏览器不会重新加载整个页面，而是会触发
hashchange事件，就可以通过js来监听这个事件实现数据的加载和页面渲染

而 history 模式：会刷新页面，会向后台服务器发送请求，如果后台没有定义这个路径的话，会返回404，因此需要后台配置重定向

hash 模式的优缺点是：

    兼容性好，所有浏览器都支持运行使用，缺点是 url 中带有 # 号，可能不太美观

history 模式的优缺点是：

    url美观嘛，用户体验好，但是兼容性不太好，需要跟后端来配合使用




## 24、vue中如何动态添加属性（首先应该想到： 动态 class\style 切换，）

在 vue 中，可以使用  v-bind 指令实现动态绑定属性，v-bind 指令可以将data中的变量绑定到指定的 html 属性上，缩写为： ':'

可以定义 class类名、style样式，通过 v-bind 绑定class和style属性，改变变量值，可以进行动态切换的效果


## 25、vue 中如何做样式穿透

在vue中，可以在想要穿透的样式选择器前面加上 >>> 符号 或者 /deep/ 还有 ::v-deep 就可以了


## 26、keep-alive 组件缓存，保持状态怎么实现刷新

keep-alive 是 vue 中内置组件，可以保存组件的状态，避免组件重复渲染

它的使用方法很简单，只需要用 keep-alive 标签包裹着要缓存的组件就可以了，这样在切换组件时，组件就不会被销毁而是保存起来

有两个独有的生命周期：activated：激活 和 deactivated：停用，可以写业务逻辑，如果要保存上一个页面的状态，则需要
使用局部路由守卫，在 beforeRouteLeave 函数中把当前页面路径以变量形式存放，在 activated 生命周期中，把跳转到变
量所保存的路径，既可以实现状态保存了

使用 keep-alive 组件在第一次加载时，会触发正常组件的生命周期基础上再多一个 activated。如 beforeCreate、created、beforeMount、mounted

如果第二次或者之后，就只会触发 activated 这个生命周期

总之，使用 keep-alive 的优势是：在组件切换过程中并不会销毁而是缓存到内存中，可以防止重复渲染DOM，减少加载时间，提高性能以及用户的体验


## 27、token 保存在哪里？

token可以保存的地方有很多，例如 localStorage、cookie、vuex、sessionStorage等地方。

比较推荐的是 localStorage、cookie ，可以很方便地实现免密登录、记住密码等功能


## 28、自己封装过组件吗？介绍一下常用的组件（待补充）




## 29、打包压缩时，dist 文件过大怎么处理

可以对项目做一下优化处理：

1. dist打包生成的文件中有 .map 文件，可以在 vue.config.js 文件中，配置 productionSourceMap:false，表示不生成 map

2. 多使用组件和路由的懒加载，按需引入

3. 第三方包通过 script 标签，CDN 的方式引入

4. 对于文件和图片进行压缩，可以安装压缩插件：compression-webpack-plugin

    下载之后在 vue.config.js 中进行配置：组件不打包、分割代码、超过一定大小的文件进行压缩等选项



## 30、vue 源码

