## 一、cookie 和 session 的区别

cookie 和 session 都是用于客户端和服务器端之间进行状态管理的技术，它们的区别主要有：

1. 存储位置不同：

    cookie 存储在客户端浏览器中，而session存储在服务器端的内存或者数据库中

2. 安全性不同：

    cookie 可以被客户端浏览器禁用或者删除，也容易被恶意攻击者窃取和篡改，因此存储敏感信息的安全性较低，而session存储在

服务器端，客户端无法直接访问，相对来说比较安全

3. 存储容量不同：

    cookie 的存储容量比较小，一般不超过4kb；而session的存储容量比较大，可以存储更多的信息

4. 过期时间不同：

    cookie的可以设置过期时间，可以长期保存在客户端浏览器中；而session的过期时间一般比较短，用户在关闭浏览器或者一段时间不活动之后就会自动过期

5. 用途不一样：

    cookie主要用于客户端浏览器与服务器端之间的状态管理，比如保存用户登录信息、购物车信息等；而session一般用于服务器端的状态管理，比如保存用户的会话信息、

缓存数据等。

总之，cookie和session都有各自的优缺点，具体使用哪种技术要看具体的需求和场景来决定。


## 二、slot 的使用

vue中的插槽有三种类型：匿名插槽、具名插槽、作用域插槽

1. 匿名插槽：

    子组件通过 slot 标签来确定插槽渲染的位置，标签内可以放入Dom结构，当父组件在使用的时候没有往插槽传入内容，标签内的dom结构就会显示在页面上；

父组件在使用的时候，直接在子组件的标签内写入内容就可以了

2. 具名插槽：

    子组件通过 name 属性来表示插槽的名字，不传就为默认插槽；

父组件在使用的时候在默认插槽的基础上加上 slot 属性，值就是子组件的插槽的 name 属性值

3. 作用域插槽：

    子组件在作用域插槽上绑定属性将自身的信息传递给父组件来使用，这些属性会挂载到父组件的 v-slot 接收的对象上；

而 v-slot 可以简写为 #，父组件通过 # 加上插槽名字 来获取子组件的信息，在内容中使用。

总结一下，有一些需要注意的地方：

- v-slot 只能在 template 标签上使用，但是当只有默认插槽的时候，可以在组件标签上使用

- 默认插槽的名字为 default ，可以省略 default 直接写 v-slot

- 当 v-slot 简写为 # 时，不能省略参数，写成 #default

- 可以通过解构获取子组件传递的变量：v-slot={user}，也可以重命名变量：v-slot="{user: aaa}"，还可以设置默认值：v-slot="{user='默认1'}"


## 三、computed 是怎么做响应式的？

computed属性是vue中的计算属性，它是一个类似于过滤器的函数，主要用于对绑定到视图的数据进行处理

- 计算属性的输出结果会被缓存下来，只有当它依赖的响应式属性发生变化才会重新计算；

- computed 属性也是响应式的，它会自动追踪依赖的响应式属性，也就是说，当依赖的响应式属性发生变化时，computed属性会重新计算，然后更新视图

- 与 methods 不同，computed 属性会自动追踪响应式依赖，不需要手动追踪，计算属性的结果是默认走缓存的，也就是基于在data中声明过的或者父组件
传递的props中的数据进行计算得到的值


## 四、vue2 和 vue3 的区别

1. 数据双向绑定 的原理不同：

在vue2中，数据双向绑定是利用 ES5 的一个 API 叫 Object.defineProperty 对数据劫持，并且结合发布订阅模式的方式去实现的

而在vue3中，数据双向绑定是使用 es6 的 Proxy 方法对数据进行代理，相比于 vue2 ，proxy 有几个好处：

- Object.defineProperty 只能监听对象的某个属性，不能对整个对象进行监听，因此 vue2 需要递归遍历所有的属性去对数据进行劫持，而 proxy 可以直接对
整个对象代理进行监听，因此节省了递归遍历等操作，明显提高了性能
    
- 可以监听数组，不用像vue2中那样对数组做特异性操作，vue3可以检测到数组内部数据的变化

2. vue3 支持 碎片化

在vue2中，template 模板标签下必须并且只能有一个根节点

而在vue3中，可以支持多个根节点

3. API 类型不同：

在 vue2 中使用的是选项式API的写法，根据不同的属性来分割代码：data、computed、methods等，当代码量比较大的时候，需要不断地上下翻滚查找数据和方法
开发可能会比较麻烦

而 vue3 采用的是 组合式API的写法，同一个业务的数据和方法写在同一个地方，相比于 vue2 的写法，vue3 的代码会更加方便和整洁

4. 定义数据变量和方法不同：

vue2 的数据变量放到 data 中管理，创建的方法放到 methods 中管理

而 vue3 的数据和方法是写到 setup 函数里面，setup 函数会在组件初始化构造的时候触发

5. 生命周期钩子函数不一样：

vue2 中的生命周期有：

    组件创建前和后：beforeCreate、created

    组件挂载前和后：beforeMount、mounted

    数据更新前和后：beforeUpdate、Updated

    以及组件销毁前后：beforeDestroy、destroyed

vue3 的生命周期把组件创建前后改成了 setup

    组件挂载前和后：onBeforeMount、onMounted

    数据更新前和后：onBeforeUpdate、onUpdated

    组件销毁前后改了名称，叫：onBeforeUnMount、onMounted

    并且 vue3 中的生命周期在使用之前要先引入。

6. 父子组件传参的方式不同

vue2 中的 父传子，子组件使用 props 接收，而 子传父使用 this.$emit 传入事件名称来触发父组件的方法并且通过参数传值

而在 vue3 的 setup 语法糖里面，父传子使用的是 defineProps 来接收，子传父使用的是 defineEmits

7. 插槽和指令不同

- 插槽：

    vue2 中的插槽可以直接使用 slot 指令，而 vue3 中必须使用 v-slot 指令

- 指令：

    vue2 中的 v-for 比 v-if 的优先级要高，并且不建议一起使用，而在 vue3 中，v-if 只是作为 v-for 的一个判断语句
不会相互冲突；

    并且在 vue3 中，移除了 keyCode 作为 v-on 的修饰符，以及移除了 v-on.native 修饰符，还有一个过滤器 filter 也从 vue3 中移除了

8. main.js 文件不同

在 vue2 的main.js中，引入的是 vue 的构造函数，并且可以使用 prototype 操作原型的方式去添加全局对象或者方法

在 vue3 中则是引入了一个名叫 createApp 的工厂函数，通过模块化的方式去组织代码，比vue更加简洁

并且 vue3 的 app.vue 组件可以没有根标签


## 五、解释一下 MVVM

MVVM 就是 model-view-viewModel，本质上是 MVC 的改进版

model 代表数据模型，数据和业务逻辑都在model层定义

view 是用户在屏幕上看到的UI视图

viewModel 负责监听 model 中数据的改变并且控制视图的更新，以及处理用户的交互逻辑

MVVM 优点是：

- 低耦合，view视图可以独立于model的变化和修改，一个viewModel可以绑定到不同的view上，view和model无直接的关联，互不影响

- 可复用性强，就是开发者可以把一些视图逻辑放在一个viewModel里面，让很多view可以复用这段逻辑

- 独立开发，业务逻辑和视图表现是分离，开发者可以专注于业务逻辑，不用过多关注界面的细节