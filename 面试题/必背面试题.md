## 1、cookie 和 session 的区别

cookie 和 session 都是用于客户端和服务器端之间进行状态管理的技术，它们的区别主要有：

1. 存储位置不同：

    cookie 存储在客户端浏览器中，而session存储在服务器端的内存或者数据库中

2. 安全性不同：

    cookie 可以被客户端浏览器禁用或者删除，也容易被恶意攻击者窃取和篡改，因此存储敏感信息的安全性较低，而session存储在

服务器端，客户端无法直接访问，相对来说比较安全

3. 存储容量不同：

    cookie 的存储容量比较小，一般不超过4kb；而session的存储容量比较大，可以存储更多的信息

4. 过期时间不同：

    cookie的可以设置过期时间，可以长期保存在客户端浏览器中；而session的过期时间一般比较短，用户在关闭浏览器或者一段时间不活动之后就会自动过期

5. 用途不一样：

    cookie主要用于客户端浏览器与服务器端之间的状态管理，比如保存用户登录信息、购物车信息等；而session一般用于服务器端的状态管理，比如保存用户的会话信息、

缓存数据等。

总之，cookie和session都有各自的优缺点，具体使用哪种技术要看具体的需求和场景来决定。


## 2、slot 的使用

vue中的插槽有三种类型：匿名插槽、具名插槽、作用域插槽

1. 匿名插槽：

    子组件通过 slot 标签来确定插槽渲染的位置，标签内可以放入Dom结构，当父组件在使用的时候没有往插槽传入内容，标签内的dom结构就会显示在页面上；

父组件在使用的时候，直接在子组件的标签内写入内容就可以了

2. 具名插槽：

    子组件通过 name 属性来表示插槽的名字，不传就为默认插槽；

父组件在使用的时候在默认插槽的基础上加上 slot 属性，值就是子组件的插槽的 name 属性值

3. 作用域插槽：

    子组件在作用域插槽上绑定属性将自身的信息传递给父组件来使用，这些属性会挂载到父组件的 v-slot 接收的对象上；

而 v-slot 可以简写为 #，父组件通过 # 加上插槽名字 来获取子组件的信息，在内容中使用。

总结一下，有一些需要注意的地方：

- v-slot 只能在 template 标签上使用，但是当只有默认插槽的时候，可以在组件标签上使用

- 默认插槽的名字为 default ，可以省略 default 直接写 v-slot

- 当 v-slot 简写为 # 时，不能省略参数，写成 #default

- 可以通过解构获取子组件传递的变量：v-slot={user}，也可以重命名变量：v-slot="{user: aaa}"，还可以设置默认值：v-slot="{user='默认1'}"


## 3、computed 是怎么做响应式的？

computed属性是vue中的计算属性，它是一个类似于过滤器的函数，主要用于对绑定到视图的数据进行处理

- 计算属性的输出结果会被缓存下来，只有当它依赖的响应式属性发生变化才会重新计算；

- computed 属性也是响应式的，它会自动追踪依赖的响应式属性，也就是说，当依赖的响应式属性发生变化时，computed属性会重新计算，然后更新视图

- 与 methods 不同，computed 属性会自动追踪响应式依赖，不需要手动追踪，计算属性的结果是默认走缓存的，也就是基于在data中声明过的或者父组件
传递的props中的数据进行计算得到的值


## 4、vue2 和 vue3 的区别

1. 数据双向绑定 的原理不同：

在vue2中，数据双向绑定是利用 ES5 的一个 API 叫 Object.defineProperty 对数据劫持，并且结合发布订阅模式的方式去实现的

而在vue3中，数据双向绑定是使用 es6 的 Proxy 方法对数据进行代理，相比于 vue2 ，proxy 有几个好处：

- Object.defineProperty 只能监听对象的某个属性，不能对整个对象进行监听，因此 vue2 需要递归遍历所有的属性去对数据进行劫持，而 proxy 可以直接对
整个对象代理进行监听，因此节省了递归遍历等操作，明显提高了性能
    
- 可以监听数组，不用像vue2中那样对数组做特异性操作，vue3可以检测到数组内部数据的变化

2. vue3 支持 碎片化

在vue2中，template 模板标签下必须并且只能有一个根节点

而在vue3中，可以支持多个根节点

3. API 类型不同：

在 vue2 中使用的是选项式API的写法，根据不同的属性来分割代码：data、computed、methods等，当代码量比较大的时候，需要不断地上下翻滚查找数据和方法
开发可能会比较麻烦

而 vue3 采用的是 组合式API的写法，同一个业务的数据和方法写在同一个地方，相比于 vue2 的写法，vue3 的代码会更加方便和整洁

4. 定义数据变量和方法不同：

vue2 的数据变量放到 data 中管理，创建的方法放到 methods 中管理

而 vue3 的数据和方法是写到 setup 函数里面，setup 函数会在组件初始化构造的时候触发

5. 生命周期钩子函数不一样：

vue2 中的生命周期有：

    组件创建前和后：beforeCreate、created

    组件挂载前和后：beforeMount、mounted

    数据更新前和后：beforeUpdate、Updated

    以及组件销毁前后：beforeDestroy、destroyed

vue3 的生命周期把组件创建前后改成了 setup

    组件挂载前和后：onBeforeMount、onMounted

    数据更新前和后：onBeforeUpdate、onUpdated

    组件销毁前后改了名称，叫：onBeforeUnMount、onMounted

    并且 vue3 中的生命周期在使用之前要先引入。

6. 父子组件传参的方式不同

vue2 中的 父传子，子组件使用 props 接收，而 子传父使用 this.$emit 传入事件名称来触发父组件的方法并且通过参数传值

而在 vue3 的 setup 语法糖里面，父传子使用的是 defineProps 来接收，子传父使用的是 defineEmits

7. 插槽和指令不同

- 插槽：

    vue2 中的插槽可以直接使用 slot 指令，而 vue3 中必须使用 v-slot 指令

- 指令：

    vue2 中的 v-for 比 v-if 的优先级要高，并且不建议一起使用，而在 vue3 中，v-if 只是作为 v-for 的一个判断语句
不会相互冲突；

    并且在 vue3 中，移除了 keyCode 作为 v-on 的修饰符，以及移除了 v-on.native 修饰符，还有一个过滤器 filter 也从 vue3 中移除了

8. main.js 文件不同

在 vue2 的main.js中，引入的是 vue 的构造函数，并且可以使用 prototype 操作原型的方式去添加全局对象或者方法

在 vue3 中则是引入了一个名叫 createApp 的工厂函数，通过模块化的方式去组织代码，比vue更加简洁

并且 vue3 的 app.vue 组件可以没有根标签


## 5、解释一下 MVVM

MVVM 就是 model-view-viewModel，本质上是 MVC 的改进版

model 代表数据模型，数据和业务逻辑都在model层定义

view 是用户在屏幕上看到的UI视图

viewModel 负责监听 model 中数据的改变并且控制视图的更新，以及处理用户的交互逻辑

MVVM 优点是：

- 低耦合，view视图可以独立于model的变化和修改，一个viewModel可以绑定到不同的view上，view和model无直接的关联，互不影响

- 可复用性强，就是开发者可以把一些视图逻辑放在一个viewModel里面，让很多view可以复用这段逻辑

- 独立开发，业务逻辑和视图表现是分离，开发者可以专注于业务逻辑，不用过多关注界面的细节


## 6、vue 的特点

vue 是一个轻量级的 JavaScript 框架，专注于视图层开发，用于构建单页面应用

还有，vue 使用 MVVM 架构，将视图层、数据层和业务逻辑分离开来，通过一些简单的API实现响应式的数据绑定和可以组合的视图组件，
让开发者可以更方便地开发和维护复杂的前端应用

vue 的特点：

一个是 数据双向绑定 机制，就是说当数据发生变化时，视图也会进行更新，不需要手动去操作 DOM 

还有一个是 组件化 开发，把代码分割成一个个独立的组件，方便我们开发和复用，同时也可以提高代码的可维护性和可扩展性

此外，vue 还有丰富的插件生态，比如路由管理的 vueRouter、状态管理的 vuex 等，提高开发效率

总的来说，vue 的优点在于它的灵活性和轻量级，它的语法、指令简单明了，学习成本低，不管是小型应用还是大型单页面应用，都可以使用 vue 来实现


## 7、什么是单页面应用（SPA）

单页面应用，也叫 single-page application 简称 SPA，也就是加载单个页面并在交互时动态刷新该页面，所有的
活动都在一个页面中进行。

单页面应用在初始化时加载相应的HTML、CSS、JavaScript 文件，利用 js 动态的切换 HTML，从而实现UI与用户的交互效果

vue 框架为单页面应用开发提供了模板、路由和异步访问数据api以及DOM操作等功能，使得前后端分离开发成为了可能

SPA的优点是：

1. 前后端分离开发，减轻了服务器的压力；

2. 移动端和PC端等可以共用一套后端接口程序代码，节省了开发成本。

SPA的缺点是：

1. SEO 难度比较高，首次加载时耗时比较长

2. 页面前进、后退的管理比较困难

针对单页面应用的前进后退的管理问题，我们可以引入 vueRouter 实现单页面应用的路由配置和导航控制，通过浏览过的一个历史记录，查看过往的页面

还有首次加载耗时长的问题，可以采用多种缓存措施，在需要的时候再进行加载模块，比如路由懒加载、数据懒加载等

最后是 SEO 优化问题，由于单页面应用的数据是动态刷新的，导致网页内容很难被搜索引擎抓取到。

一般有两种解决方案：一种是服务端渲染，还有一种是前端预渲染。

关于前端预渲染：

1. 使用插件 prorender-spa-plugin，下载安装之后在 vue.config.js 中进行配置，配置好这个默认预编译的路劲、路由和渲染方式

2. 然后在 main.js 中引入，并且要把 vueRouter 路由模式改成 history,然后进行打包


##  8、data为啥是函数

在js中，对象是引用数据类型，也就是说如果 data 是一个对象时，每个组件实例的data对象引用的都是同一个内存地址，一个实例数据改变了，其他的
data也会收到影响跟着改变；

而如果 data 是一个函数，它会创建一个函数作用域作为自己的私有域，每个组件实例的data都是独立的，互不影响，可以保证组件的一个正常工作。

## 9、数据双向绑定的原理

vue 中实现的这个数据双向绑定，首先要对数据进行劫持监听，用到了 Object.definedProperty() 的 get 和 set 方法，然后还需要一个监听器 Observer，
来监听所有属性。如果属性发生了变化，就告诉订阅者 Watcher 看是否需要更新。

因为 订阅者 是有很多个的，所以需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和 订阅者 Watcher 之间进行一个统一管理。

接着，我们还需要有一个指令解析器 Compile，对每个元素节点进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并且替换模板数据或者绑定相应的函数，
此时当订阅者 Watcher 接收到相应属性的变化时，就会触发执行对应的更新函数，这一点实在 js 文档碎片中完成的，从而更新了视图。

以上就是我所了解的数据双向绑定的原理~


## 10、computed、methods、watch

computed 是 vue 中的计算属性，它可以用来解决模板过重的问题。计算属性必须要 return 返回一个结果，并且具有缓存功能，可以提高性能。

computed 注重这个计算结果，不支持异步操作。

methods 选项是用来存放方法的，方法可以用来处理事件绑定和逻辑计算，跟 computed 不同，方法可以不用 return 一个结果，并且没有缓存功能。

watch 可以用来监听某一个值的变化，在值发生变化的时候可以做一些操作。watch 也可以不用 return 返回值，也没有缓存。但是它同时支持异步或者同步操作。

总之，computed、methods以及 watch 都是用于处理数据的选项，它们各自具有不同的特点和使用场景。可以根据具体的业务需求和场景来使用。


## 11、v-if 和 v-show 的区别

v-if 和 v-show 这两个指令都可以用来控制 DOM 元素的显示和隐藏，不同的是：

v-if 是真正的条件渲染，它会在元素显示隐藏的切换过程中销毁和重建条件块内的事件监听器和子组件；而v-show只是简单的基于CSS样式来进行切换。

v-if 在首次渲染时，如果条件为真，就会创建和渲染条件块的元素，如果条件为false，那它什么也不会做；

而 v-show 在首次渲染时，不管条件为真还是假，都会创建和渲染元素

总结一下，v-if 是切换的开销高，v-show 的初次渲染的开销才比较高，

因此，如果是需要频繁进行切换的场景，使用 v-show 性能会更好，如果条件很少改变，使用v-if可能会比较好。

但还是需要结合具体的业务需求和场景来选择使用。


 