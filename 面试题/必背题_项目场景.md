## 1、微信扫码登陆

我之前做的一个 electron 的项目，是进行后台管理的，其中就有扫码登陆的功能，
首先对需要扫码登陆的账号绑定相关的微信登陆的信息，
绑定之后就可以使用微信扫码来进行登陆了

这个绑定微信的过程：

1. 在用户管理页面，点击绑定按钮：此时就会发送消息通知主进程 （渲染进程 给主进程传递token）

2. 主进程收到消息就会创建一个新窗口，这个新窗口里面渲染了一张后端给前端的二维码图片，通过微信扫码绑定

3. 扫码之后，就把页面关闭，然后监听url的改变：

    - 如果 url 发生变化，就发送一个请求，携带token、绑定信息等参数

4. 前端这边发送请求之后，后端那边做一些处理，然后给微信的服务器发送请求，会得到一个 code 码最后返回前端

5. 主进程这边接收到 code 码之后，就发给渲染进程，渲染进程拿到之后就提示微信已经授权等信息，然后再把code码
发到后台去保存，后台那边就会返回已经绑定了，绑定成功等提示消息

6. 把账号绑定了微信登陆信息之后，我们就可以使用这个账号来进行扫码登陆了，在登陆页面点击扫码登陆：

7. 这时候主进程会弹出一个扫码登陆的页面，扫码之后会发送一个登陆请求，返回微信授权的code码，主进程把这个
code码发送到渲染进程，渲染进程拿到code码之后，把code码发送到后台进行校验，验证通过之后就返回用户信息，
然后就是正常的登陆流程了


## 2、登陆鉴权

首先是在登录页面登录，输入用户名和密码，点击登陆就会发送一个登陆请求：

1. 登录成功后台就会返回一些数据，然后这里的操作可以写一个 hooks，在 hooks 里面获取 token 并且写入 
localStorage 中，并且在 hooks 里面还会调用 store，store 通过 token 获取用户信息，包括权限码和用户的其他信息


2. 当用户登录到主界面的时候，页面路由是根据 动态获取的菜单列表数据中的 url 信息动态添加的：

    - 首先，从接口获取菜单数据，但返回的菜单数据可能不符合我们前端多级菜单组件的格式要求，因此需要
    对数据进行重构

    - 把数据重构成可以方便遍历访问的 二级菜单数据格式

    - 然后构造路由表，是一个数组，里面元素是一个个路由对象，有 path，name，component等属性

    - 通过 addRoute 方法，把重构的路由对象动态添加到路由表中

    - 登录成功之后，左侧的菜单栏会根据 这个权限码获取到对应的菜单信息，动态渲染出来，
        也就是说：超级管理员可能有30个菜单数据，而普通用户只显示10个菜单


3. 页面权限，判断某某用户如果没有对应的权限不可以进入某某路由

    - 在 beforeEach 前置导航守卫里面进行判断：

        - 如果是超级管理员直接next通行

        - 如果不是超级管理员，需要拿到当前用户的所有路由信息（扁平化：map对象）和
            当前的路由判断，如果不存在，就提示用户并跳转到一个错误页面

4. 按钮级别权限，可以使用自定义指令对页面的按钮、超链接也做权限控制，流程大概是：

    - 用户登录的时候，需要请求 【个人信息】 的接口，然后接口会返回一些用户信息，里面包括了 权限信息

    - 这时候我们把从后端返回的 用户的 “权限信息” 保存起来

    - 然后新建一个自定义指令 v-auth='某某权限字符'，这个自定义指令的逻辑是：

        1、先判断指令有没有传值，是否正确传值

        2、在用户的权限信息中，查询有没有该指令对应的权限信息

        3、有就return，没用就获取指令元素的父级，通过removeChild删除该元素，把按钮删除


5. 总结一下，其实权限是由角色来控制的：

    - 给某个用户新增一个权限，其实就是给用户添加一个角色

    - 角色的添加过程是：

        - 点击角色新增按钮

        - 通过请求去获取菜单权限树

        - 选择对应的权限，其实就是选择了某权限的id

        - 当点击【确认新增】，需要给后端发送请求，传递 权限id 等参数

        - 后端那边会把多个权限id，组合成一个 角色， 一个角色对应一个ID（ 这个id就是多个权限生成）

    - 如果要给某个用户删除一个权限，其实就是在用户上删除一个角色

    - 注意：如果当前用户正在使用这个角色来获得操作角色增删改的权限，那么它直接删除这个角色后台会报引用资源错误


这就是我所做的 登录鉴权


## 3、你在项目中怎么划分组件，封装组件的？


## 4、有做过即时通信吗？（有了解 socket \ websocket 吗？）

websocket 是全双工通信，也是基于 tcp 协议，浏览器和服务器只需要一次握手就可以建立持久连接，进行双向数据传输

不仅客户端可以给服务器发送消息，服务器也可以主动向客户端发送消息，没有同源限制，实时性更强

用法大概如下：

首先 new 一个 websocket: ``let ws = new WebSocket(url)``, 其中参数 url 是 ``ws://1270.0.0.1:9999``，协议标识符为 ws

1. 连接成功后触发open事件，使用 ws.onopen(callback) 或者 ws.addEventListener('open', callback) 设置事件回调函数

2. 服务器发送消息过来触发 message 事件，关闭连接触发 close 事件，连接失败就触发 error 事件

3. 

应用场景呢，

1. 一个公司可以开发一个基于 websocket 的即时通信系统，这样每个员工的所有操作都有痕迹，出了问题可查

2. 股票系统，请求的股票数据每秒都要刷新，延时要很低，服务器要不断地推送数据给客户端



## 5、性能优化

1. 前端性能优化的方向：

1、请求优化：减少请求次数

2、数据优化：压缩、懒加载

3、配置优化：

- webpack：那些配置项优化了，作用是什么[视频链接](https://www.bilibili.com/video/BV1eC4y147RX/?spm_id_from=333.337.search-card.all.click)

- vite：[视频链接](https://www.bilibili.com/video/BV1P54y1y7YQ/?spm_id_from=333.337.search-card.all.click)


2. 虚拟列表

**相关面试题**：首页加载的数据有 10 万条，怎么处理加载的问题

1、分批获取数据：可以通过懒加载、分页方式

- 分页：点击下一页/页码的时候，再次发送请求 重新请求阶段数据

- 懒加载：监听滚动事件，触发事件 向后端请求数据 --> 阶段数据

缺点：增加请求数

2、一次性拿10万条数据：通过虚拟列表，分段加载到页面上

- 首先计算，数据的开始 和 结束位置以及每一屏的记录数，每一行的高度

- 通过计算属性，slice() 截取 需要加载的单屏的数据

- 计算单屏的高度 和 所有数据的总高度，然后监听滚动事件 计算滚动上去的行数，

- 计算滚动后的开始和结束记录，平移到数据列表中


虚拟列表（Virtual List）又称无限滚动列表或者长列表优化，是一种前端性能优化技术。其主要目的是在处理大量数据列表时，
提高用户体验和页面性能。以下是虚拟列表的基本原理：

1. 渲染可视区域的列表项：虚拟列表的核心思想是仅渲染可见部分的列表项。当用户滚动列表时，根据可视区域的大小，
计算需要显示的列表项，然后只渲染这些列表项。

2. 列表项的位置计算：虚拟列表需要计算每个列表项的位置信息，以便在滚动过程中正确地显示列表项。这通常通过索引和固定高度（或者预估高度）来实现。

3. 复用列表项DOM元素：为了减少创建和销毁DOM元素的性能开销，虚拟列表通常会复用列表项的DOM元素。当一个列表项滚出可视区域时，
它的DOM元素会被重新利用，用于显示新的列表项。

4. 占位元素：虚拟列表通常会使用一个占位元素（如一个空的div）来模拟整个列表的高度。这样可以使滚动条保持正确的位置和大小，
使用户能够像正常列表一样进行滚动操作。

5. 事件监听与更新：虚拟列表需要监听滚动事件，以便在用户滚动时实时更新可视区域的列表项。此外，如果列表数据发生变化，
虚拟列表还需要重新计算位置信息并更新可视区域的列表项。

通过上述原理，虚拟列表能够显著减少大量列表项的渲染成本，从而提高页面的性能和用户体验。在实际应用中，
根据项目的具体需求和场景，可能还需要对虚拟列表进行一定的定制和优化。


## 6、OSS 上传

之前的项目中使用了阿里的oss，首先要安装：``npm install ali-oss``

下载之后要进行一些配置，导入一个 OSS 类：`` import OSS from 'ali-oss' ``

然后 new 一个OSS实例并且传入一些初始化的参数：

```
export const client = new OSS({
    bucket: '',
    region: '',
    accessKeyId: '',
    accessKeySecret: '',
    endpoint: '',
    secure: ''
})


```

第一个参数是 bucket，存储空间的名称，还有 region 注册区域，keyID 访问ID、密钥
 和 外网访问的区域节点 endpoint和https的开关等参数